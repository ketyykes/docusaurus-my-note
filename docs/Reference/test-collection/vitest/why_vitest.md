---
sidebar_position: 1
title: 為什麼選擇 Vitest
description: 深入探討 Vitest 測試框架的優勢與特色，包含原生 Vite 整合、高效能測試執行、開發體驗優化等核心功能，以及如何在不同專案中靈活運用
tags:
  - test
last_update:
  date: 2025-05-28
  author: Danny
---

# 為什麼選擇 Vitest

> **注意**  
> 本指南假設你已經熟悉 Vite。建議你可以先閱讀「為什麼選擇 Vite」這份指南，或觀看 Evan You 的直播「Next generation frontend tooling with ViteJS」，他在裡面詳細介紹了主要概念。

## 為什麼需要原生支援 Vite 的測試執行器

Vite 原生支援常見的網頁開發模式，像是 glob 匯入、SSR 原語，以及豐富的外掛和整合，讓生態系非常活躍。它的開發與建置流程也是成功的關鍵。對於文件來說，已經有好幾個基於 Vite 的 SSG 替代方案。不過，Vite 的單元測試方案一直不夠明確。現有的選擇像是 Jest，是在不同的時空背景下誕生的。Jest 和 Vite 之間有很多重複的地方，導致使用者必須設定兩套不同的流程。

在測試時利用 Vite 的開發伺服器來轉換你的檔案，可以讓測試執行器變得更簡單，不需要處理原始碼轉換的複雜性，只需專注於提供最佳的開發體驗（DX）。這樣的測試執行器會使用和你的應用程式（透過 `vite.config.js`）相同的設定，讓開發、建置和測試時都能共用同一套轉換流程。它也能用同一套外掛 API 擴充，讓你和工具維護者都能為 Vite 提供一流的整合。這是一個從一開始就以 Vite 為核心設計的工具，能充分利用 Vite 在開發體驗上的進步，例如即時熱模組重載（HMR）。這就是 Vitest——一個由 Vite 驅動的新世代測試框架。

考量到 Jest 的廣泛使用，Vitest 提供了相容的 API，讓你可以在大多數專案中直接替換使用。它也內建了設定單元測試時最常用的功能（如 mock、快照、覆蓋率）。Vitest 非常重視效能，盡可能利用 Worker 執行緒平行執行測試。有些專案甚至測試速度提升了數十倍。預設啟用 Watch 模式，這也呼應了 Vite 強調「開發優先」的理念。即使有這麼多 DX 的提升，Vitest 依然保持輕量，謹慎選擇依賴（或直接內嵌必要的元件）。

Vitest 的目標是成為 Vite 專案的首選測試執行器，即使不是用 Vite 的專案，也是一個很棒的替代方案。


